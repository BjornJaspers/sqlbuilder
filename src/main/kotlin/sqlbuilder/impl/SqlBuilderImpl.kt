package sqlbuilder.impl

import sqlbuilder.usea
import kotlin.jdbc.map
import javax.sql.DataSource
import sqlbuilder.SqlBuilder
import sqlbuilder.Backend
import java.sql.Connection
import sqlbuilder.CacheableQuery
import java.lang.ref.SoftReference
import sqlbuilder.Configuration
import sqlbuilder.Select
import sqlbuilder.Insert
import sqlbuilder.Delete
import sqlbuilder.Update
import sqlbuilder.PersistenceException
import java.sql.SQLException
import java.sql.ResultSet
import org.slf4j.LoggerFactory
import java.util.concurrent.ConcurrentHashMap
import sqlbuilder.meta.PropertyReference

public class SqlBuilderImpl(private val dataSource: DataSource) : SqlBuilder, Backend {
    private val logger = LoggerFactory.getLogger(javaClass)

    private val txConnections = ThreadLocal<Connection>()
    private val caches = ConcurrentHashMap<String, MutableMap<CacheableQuery, SoftReference<Any>>>()
    private val globalCache = ConcurrentHashMap<CacheableQuery, SoftReference<Any>>()

    override var configuration: Configuration = Configuration()

    override fun select(): Select {
        return SelectImpl(this)
    }

    override fun insert(): Insert {
        return InsertImpl(this)
    }

    override fun delete(): Delete {
        return DeleteImpl(this)
    }

    override fun update(): Update {
        return UpdateImpl(this)
    }

    override fun <T> save(bean: T, vararg excludedFields: String): T {
        val metaResolver = configuration.metaResolver
        val keys = metaResolver.getKeys(bean.javaClass)
        if (keys.size() == 1 && keys[0] == "id") {
            val idField = metaResolver.findField("id", bean.javaClass)
            if (idField == null) throw IllegalArgumentException("bean <${bean.javaClass}> has no id field")
            idField.setAccessible(true)

            val valueBefore = idField.get(bean)
            if (valueBefore != null) {
                update().excludeFields(*excludedFields).updateBean(bean)
            } else {
                val id = insert()
                        .getKeys(true)
                        .excludeFields(*excludedFields)
                        .insertBean(bean)
                try {
                    idField.set(bean, id)
                } catch (e: Exception) {
                    throw PersistenceException("unable to set autogenerated id on " + bean.javaClass.getName(), e)
                }
            }
        } else {
            throw IllegalArgumentException("cannot save object without a single id described in the KEYS")
        }
        return bean
    }

    throws(PersistenceException::class )
    override fun getSqlConnection(): Connection {
        try {
            var connection = txConnections.get()
            if (connection == null) {
                connection = dataSource.getConnection()
            }
            return connection!!
        } catch (e: SQLException) {
            throw PersistenceException(e.getMessage(), e)
        }

    }

    /**
     * Start a transaction with default isolation.
     */
    override fun startTransaction() {
        startTransaction(-1, false)
    }

    /**
     * Start a transaction using an isolationlevel other than TRANSACTION_READ_COMMITTED
     * @param isolationLevel Connection.TRANSACTION_...
     */
    override fun startTransaction(isolationLevel: Int, readonly: Boolean) {
        try {
            var connection = txConnections.get()
            if (connection == null) {
                connection = dataSource.getConnection()
                if (isolationLevel >= 0) connection!!.setTransactionIsolation(isolationLevel)
                connection!!.setAutoCommit(false)
                txConnections.set(connection)
            }
            connection.setReadOnly(readonly)
        } catch (e: SQLException) {
            throw PersistenceException(e.getMessage(), e)
        }

    }

    override fun commitTransaction() {
        val connection = txConnections.get()
        if (connection != null) {
            txConnections.set(null)
            try {
                connection.commit()
                connection.setAutoCommit(true)
            } catch (ignore: SQLException) {
            }

            closeConnection(connection)
        }
    }

    override fun closeConnection(connection: Connection) {
        if (txConnections.get() == null) {
            try {
                connection.close()
            } catch (ignore: SQLException) {}

        }
    }

    /**
     * This must be called in the a finally clause whenever you have started a transaction.
     * <br/>If commitTransaction has already been called, it will only cleanup resources,
     * else it will rollback the transaction.
     */
    override fun endTransaction() {
        val connection = txConnections.get()
        if (connection != null) {
            txConnections.set(null)
            try {
                connection.rollback()
                connection.setAutoCommit(true)
            } catch (ignore: SQLException) {}

            closeConnection(connection)
        }
    }

    override fun getCache(cacheId: String?): MutableMap<CacheableQuery, SoftReference<Any>> {
        if (cacheId != null) {
            var specificCache = caches.get(cacheId)
            if (specificCache == null) {
                specificCache = ConcurrentHashMap<CacheableQuery, SoftReference<Any>>()
                caches.put(cacheId, specificCache)
            }
            return specificCache
        }
        return globalCache
    }

    override fun purgeCache(cacheId: String) {
        getCache(cacheId).clear()
    }

    override fun purgeAllCaches() {
        caches.clear()
        globalCache.clear()
    }

    override fun isInTransaction(): Boolean {
        return txConnections.get() != null
    }

    throws(SQLException::class)
    override fun checkNullability(entity: String, bean: Any, sqlCon: Connection, getters: List<PropertyReference>) {
        val dotIdx = entity.indexOf('.')
        val schema: String?
        val table: String
        if (dotIdx > 0) {
            schema = entity.substring(0, dotIdx).toUpperCase()
            table = entity.substring(dotIdx + 1).toUpperCase()
        } else {
            table = entity.toUpperCase()
            schema = null
        }
        logger.trace("checking nullability for {}.{}", schema, table)

        val nonNullColumns = sqlCon.getMetaData()?.getColumns(null, schema, table, null)!!.usea { cRs: ResultSet ->
            cRs.map { set ->
                if (cRs.getInt(11) != 1) cRs.getString(4)!! else null
            }
        }.filterNotNull()

        val missingProperties = nonNullColumns.filter { nonNull ->
            getters.firstOrNull { it.name.equals(nonNull, ignoreCase = true) } == null
        }

        if (!missingProperties.isEmpty()) {
            throw PersistenceException("column(s) $missingProperties are not nullable, yet not included in your update/insert")
        }
    }
}
package sqlbuilder.impl

import org.slf4j.LoggerFactory
import sqlbuilder.Backend
import sqlbuilder.CacheableQuery
import sqlbuilder.Configuration
import sqlbuilder.Delete
import sqlbuilder.Insert
import sqlbuilder.PersistenceException
import sqlbuilder.Select
import sqlbuilder.SqlBuilder
import sqlbuilder.Update
import sqlbuilder.meta.PropertyReference
import sqlbuilder.usea
import java.lang.ref.SoftReference
import java.sql.Connection
import java.sql.ResultSet
import java.sql.SQLException
import java.util.ArrayList
import java.util.concurrent.ConcurrentHashMap
import javax.sql.DataSource

class SqlBuilderImpl(private val dataSource: DataSource) : SqlBuilder, Backend {
    private val logger = LoggerFactory.getLogger(javaClass)

    private val txConnections = ThreadLocal<Connection>()
    private val caches = ConcurrentHashMap<String, MutableMap<CacheableQuery, SoftReference<Any>>>()
    private val globalCache = ConcurrentHashMap<CacheableQuery, SoftReference<Any>>()

    override var configuration: Configuration = DefaultConfiguration()

    override val metaResolver = configuration.createMetaResolver()

    override fun select(): Select {
        return SelectImpl(this)
    }

    override fun insert(): Insert {
        return InsertImpl(this)
    }

    override fun delete(): Delete {
        return DeleteImpl(this)
    }

    override fun update(): Update {
        return UpdateImpl(this)
    }

    override fun <T : Any> save(bean: T, vararg excludedFields: String): T {
        val keys = metaResolver.getKeys(bean.javaClass)
        val singleKey = keys.singleOrNull() ?: throw IllegalArgumentException("bean <${bean.javaClass}> has no single primary key")
        val valueBefore = singleKey.get(bean)
        if (valueBefore != null) {
            update().excludeFields(*excludedFields).updateBean(bean)
        } else {
            val id = insert()
                    .getKeys(true)
                    .excludeFields(*excludedFields)
                    .insertBean(bean)
            try {
                singleKey.set(bean, id)
            } catch (e: Exception) {
                throw PersistenceException("unable to set autogenerated id on " + bean.javaClass.name, e)
            }
        }
        return bean
    }

    @Throws(PersistenceException::class)
    override fun getSqlConnection(): Connection {
        try {
            var connection = txConnections.get()
            if (connection == null) {
                connection = dataSource.connection
            }
            return connection!!
        } catch (e: SQLException) {
            throw PersistenceException(e.message, e)
        }

    }

    override fun startTransaction() {
        startTransaction(-1, false)
    }

    override fun startTransaction(isolationLevel: Int, readonly: Boolean) {
        try {
            var connection = txConnections.get()
            if (connection == null) {
                connection = dataSource.connection
                if (isolationLevel >= 0) connection!!.transactionIsolation = isolationLevel
                connection!!.autoCommit = false
                txConnections.set(connection)
            }
            connection.isReadOnly = readonly
        } catch (e: SQLException) {
            throw PersistenceException(e.message, e)
        }

    }

    override fun commitTransaction() {
        val connection = txConnections.get()
        if (connection != null) {
            txConnections.set(null)
            try {
                connection.commit()
                connection.autoCommit = true
            } catch (ignore: SQLException) {
            }

            closeConnection(connection)
        }
    }

    override fun closeConnection(connection: Connection) {
        if (txConnections.get() == null) {
            try {
                connection.close()
            } catch (ignore: SQLException) {}

        }
    }

    override fun endTransaction() {
        val connection = txConnections.get()
        if (connection != null) {
            txConnections.set(null)
            try {
                connection.rollback()
                connection.autoCommit = true
            } catch (ignore: SQLException) {}

            closeConnection(connection)
        }
    }

    override fun getCache(cacheId: String?): MutableMap<CacheableQuery, SoftReference<Any>> {
        if (cacheId != null) {
            var specificCache = caches[cacheId]
            if (specificCache == null) {
                specificCache = ConcurrentHashMap<CacheableQuery, SoftReference<Any>>()
                caches.put(cacheId, specificCache)
            }
            return specificCache
        }
        return globalCache
    }

    override fun purgeCache(cacheId: String) {
        getCache(cacheId).clear()
    }

    override fun purgeAllCaches() {
        caches.clear()
        globalCache.clear()
    }

    override fun isInTransaction(): Boolean {
        return txConnections.get() != null
    }

    @Throws(SQLException::class)
    override fun checkNullability(entity: String, bean: Any, sqlCon: Connection, getters: List<PropertyReference>) {
        val dotIdx = entity.indexOf('.')
        val schema: String?
        val table: String
        if (dotIdx > 0) {
            schema = entity.substring(0, dotIdx).toUpperCase()
            table = entity.substring(dotIdx + 1).toUpperCase()
        } else {
            table = entity.toUpperCase()
            schema = null
        }
        logger.trace("checking nullability for {}.{}", schema, table)

        val nonNullColumns = sqlCon.metaData?.getColumns(null, schema, table, null)!!.usea { cRs: ResultSet ->
            val columns = ArrayList<String>()
            while (cRs.next()) {
                if (cRs.getInt(11) != 1) {
                    columns.add(cRs.getString(4))
                }
            }
            columns
        }.filterNotNull()

        val missingProperties = nonNullColumns.filter { nonNull ->
            getters.firstOrNull { it.columnName.equals(nonNull, ignoreCase = true) } == null
        }

        if (!missingProperties.isEmpty()) {
            throw PersistenceException("column(s) $missingProperties are not nullable, yet not included in your update/insert")
        }
    }
}